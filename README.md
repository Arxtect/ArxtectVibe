了解了，我将为你的新项目（一个基于 Yjs 协同编辑的 LaTeX 文档平台，部署于 GitHub Pages，前端采用 Vite + React + 模块化 vibe coding 模式）设计一份完整的项目结构方案与 README.md 文件。

该 README 将包含：

* 模块化协作开发结构设计（支持多人并行）
* 前端统一数据中间件（区分后端与本地数据源）
* WASM 编译集成建议
* 按功能隔离的模块划分与 TODO 区块
* 支持 Cursor + Claude 开发的开发规范

我将生成结构化、可落地的 README.md，作为新项目的开发起点，并匹配你现有的团队协作与测试流程需求。稍后我将提供可下载版本。

# 基于 Yjs 的协同 LaTeX 编辑平台前端项目

[![Deploy to Production](https://github.com/Arxtect/ArxtectVibe/actions/workflows/deploy.yml/badge.svg)](https://github.com/Arxtect/ArxtectVibe/actions/workflows/deploy.yml)
[![Continuous Integration](https://github.com/Arxtect/ArxtectVibe/actions/workflows/ci.yml/badge.svg)](https://github.com/Arxtect/ArxtectVibe/actions/workflows/ci.yml)
[![Build Status](https://github.com/Arxtect/ArxtectVibe/actions/workflows/build.yml/badge.svg)](https://github.com/Arxtect/ArxtectVibe/actions/workflows/build.yml)
[![Tests](https://github.com/Arxtect/ArxtectVibe/actions/workflows/test.yml/badge.svg)](https://github.com/Arxtect/ArxtectVibe/actions/workflows/test.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.0+-blue.svg)](https://www.typescriptlang.org/)
[![React](https://img.shields.io/badge/React-18.2+-61DAFB.svg)](https://reactjs.org/)
[![Vite](https://img.shields.io/badge/Vite-5.0+-646CFF.svg)](https://vitejs.dev/)

## 项目目标与简介

本项目旨在构建一个支持多人实时协同编辑 LaTeX 文档的前端平台，类似 Overleaf 等在线 LaTeX 编辑器，但采用全新的技术栈与开发方式。平台支持完整的多文件 LaTeX 项目协作：用户可在浏览器中同时编辑多个 `.tex` 文件，所有更改通过 **Yjs** CRDT 实时同步给其他在线协作者。Yjs 使多个用户同时编辑文档时不会产生冲突，并且具备脱机编辑和分布式同步能力。前端使用 **Vite + React + TypeScript + TailwindCSS** 构建，部署于 GitHub Pages（纯前端静态部署）。页面加载后，用户登录并打开项目，即可加入对应的协同会话，通过 Yjs 的网络协议（如 WebRTC 或 WebSocket）实现编辑内容的实时共享。

与传统协同编辑不同的是，本平台的 LaTeX 编译工作在前端完成。我们集成了一个基于 WebAssembly 的 LaTeX 编译器模块，由外部团队维护并提供使用接口。得益于 WebAssembly 技术，将 TeX 引擎编译为 WASM 后，可以在浏览器中以接近原生的速度运行完整的 LaTeX 编译流程。这意味着用户每次编译都会直接在本地生成 PDF 输出和日志，无需后端服务器参与，从而减少服务器负载并提升编译响应速度。编译模块以插件形式集成，提供诸如 `compile(project)` 等方法，将当前项目的所有 `.tex` 文件打包传入 WASM 引擎进行编译，并返回PDF文件（二进制）或编译日志等结果。

后端主要提供**项目管理**相关的 REST API（已由后台团队实现并提供了正式文档）。这些 API 包括：用户认证（登录/注销）、获取用户有权限的项目列表、新建或删除项目、项目协作者权限管理、以及（如适用）运行日志的历史记录查询等接口。前端通过统一的数据中间件与后端交互，以获取初始的项目结构、保存项目元数据，以及在必要时将内容变更或编译结果通知后端。需要注意的是，文档内容的协同编辑由前端的 Yjs 机制处理，后端不直接参与内容同步，但可定期接收项目保存请求用于持久化存储。

本项目采用模块化、AI 辅助驱动的开发方式。所有前端功能将拆分为独立的模块单元进行开发，每个模块围绕单一功能，彼此解耦（例如登录模块、项目列表模块、编辑器模块等，详见下文结构）。开发过程中将充分利用 **"Vibe Coding"氛围编程** 方法：开发者通过对话式地向大型语言模型（如 Claude）描述需求，由 AI 生成代码，实现快速迭代。这种方法让我们专注于高层次设计和架构，把底层代码实现交给 AI 完成，从而提高开发效率。整个开发流程以 **README + 模块任务列表** 为指导，确保 AI 和开发者在 Cursor 编辑器中的协同工作有清晰的目标和边界。

## CI/CD 工作流程

本项目采用分支策略的 CI/CD 流程，确保代码质量和部署安全：

### 🔄 持续集成 (CI)
- **触发条件**: 推送到任何分支
- **执行内容**: 代码质量检查、TypeScript 类型检查、单元测试、构建验证

### 🧪 测试与构建检查
- **触发条件**: 推送到功能分支或主要分支
- **执行内容**: 完整测试套件、多版本构建验证、代码覆盖率报告

### 🚀 生产部署
- **触发条件**: **仅推送到 `release` 分支**
- **执行内容**: 完整 CI 检查 + 自动部署到 GitHub Pages

> 📖 详细的分支策略和开发工作流程请参考 [分支策略文档](.github/BRANCHING_STRATEGY.md)

## 快速开始

### 环境要求

- Node.js >= 18.0.0
- npm >= 8.0.0

### 安装与运行

1. **克隆项目**
```bash
git clone https://github.com/Arxtect/ArxtectVibe.git
cd ArxtectVibe
```

2. **安装依赖**
```bash
npm install
```

3. **配置环境变量**（可选）
```bash
# 创建本地环境变量文件
cp .env.example .env.local
# 编辑 .env.local 设置后端API地址
```

4. **启动开发服务器**
```bash
npm run dev
```

项目将在 http://localhost:3000 启动

### 构建与部署

1. **构建生产版本**
```bash
npm run build
```

2. **本地预览构建结果**
```bash
npm run preview
```

3. **部署到 GitHub Pages**
   - 确保仓库设置中启用了 GitHub Pages，Source 选择 "GitHub Actions"
   - **只有推送代码到 `release` 分支才会触发自动部署**
   - 其他分支只会运行测试和构建检查

### 开发工具

- **代码格式化**: `npm run format`
- **代码检查**: `npm run lint`

## 模块结构图（文字格式）

项目代码按功能模块划分，采用清晰的目录结构，各模块职责单一，方便独立开发和测试。以下是前端主要模块和核心结构：

* **`src/core/dataBridge.ts`** – 前端数据中间件核心模块。负责封装后端 API 调用和全局状态管理，将服务端数据与前端状态进行同步更新。
* **`src/modules/Login/`** – **登录模块**。提供用户登录界面和逻辑（例如组件 `Login.tsx`），处理用户身份认证，调用后端登录 API，保存用户会话令牌等。
* **`src/modules/ProjectList/`** – **项目列表模块**。显示当前用户有权限访问的所有 LaTeX 项目列表（组件如 `ProjectList.tsx`）。允许新建项目、查看项目详情，点击进入项目编辑等操作。
* **`src/modules/Editor/`** – **编辑器模块**。LaTeX 文档协同编辑主界面（组件如 `Editor.tsx`），支持打开项目下多个文件进行编辑。内含子组件：文件树/列表视图（用于切换和管理文件）、文本编辑器（集成如 CodeMirror 等，与 Yjs 文本类型绑定，实现多人实时编辑）、PDF 预览面板（渲染编译生成的文档预览）、编译触发控件等。
* **`src/modules/RunLogPanel/`** – **运行日志面板模块**。用于显示 LaTeX 编译输出的日志信息（组件如 `RunLogPanel.tsx`）。在用户触发编译后，实时输出编译过程中生成的消息，包括错误、警告和提示信息，方便调试文档编译问题。
* **`src/modules/PermissionPanel/`** – **权限控制面板模块**。用于管理项目的协作权限（组件如 `PermissionPanel.tsx`）。提供界面查看项目成员列表及其权限角色，支持邀请新协作者、修改协作者权限（只读/编辑/管理员等）、移除协作者等功能。

此外，可能还有一些辅助模块和配置：

* **`src/App.tsx`** 等应用入口文件：负责路由和整体布局，将上述各模块组合在一起。通过 React Router 配置登录页、项目列表页、编辑器页等导航关系。
* **`src/utils/`**（如果需要）：通用工具函数模块，可以存放例如格式化时间、通知封装、权限判断等跨模块公用的辅助函数。
* **Tailwind CSS 配置**、**ESLint 配置** 等工程文件：用于统一样式和代码风格，不在此详述。

上述结构以模块划分清晰展现了项目的功能构成。每个模块在开发时可以独立运行和调试，模块之间通过**数据中间件**和明确定义的接口交互，减少耦合度，增强代码复用性和可维护性。

## 各模块状态表

项目采用模块负责人制度和测试跟踪机制。下表列出了各功能模块的负责人、当前测试状态及模块简要描述。团队成员可据此认领任务并追踪开发进度。

| 模块                | 负责人 | 测试状态 | 模块描述                                                                              |
| ----------------- | --- | ---- | --------------------------------------------------------------------------------- |
| 数据中间件（dataBridge） | 待定  | 基础实现  | **核心数据桥接层**：封装后端API请求与缓存，本地状态管理，提供统一接口给各前端模块读取和更新数据。已实现基础框架和主要API方法。                              |
| 登录模块              | 待定  | 基础实现  | **用户认证**：提供登录界面，调用后端认证接口校验用户身份，管理会话状态（如JWT令牌），处理登录错误提示等。UI界面已完成。                          |
| 项目列表模块            | 待定  | 基础实现  | **项目导航**：登录后首页，显示用户有权访问的所有项目列表。支持查看项目详情、新建项目入口、进入选定项目的编辑器界面等功能。基础UI已实现。                   |
| 编辑器模块             | 待定  | 框架搭建  | **协同编辑核心**：项目主工作界面，包含文件列表视图、多标签文本编辑器（与Yjs同步）、编译触发与PDF预览等。已搭建基础框架，待集成编辑器和Yjs。 |
| 运行日志面板模块          | 待定  | 基础实现  | **编译日志输出**：实时显示LaTeX编译过程中产生的信息，包括错误、警告、成功提示等。已实现UI组件。                 |
| 权限控制面板模块          | 待定  | 基础实现  | **项目共享设置**：提供UI管理项目协作者权限。支持邀请新用户加入项目、设置其权限级别（编辑者/只读等）、移除用户等操作。基础UI已完成。             |

*备注*: 
- **基础实现**：模块的主要UI和基本功能已实现，但可能缺少部分高级功能或与其他模块的集成
- **框架搭建**：模块的基本结构已创建，但核心功能尚未实现

## 开发规范

为确保多人协作和 AI 编程的顺利进行，我们制定以下前端开发规范。这些规范涵盖 AI 提示使用、代码风格、模块划分和日志等方面，旨在提高代码质量和开发效率。

### AI (Claude) 提示使用建议

* **提供充分的上下文**：在使用 Claude 等大型语言模型进行编码时，应在提示中提供尽可能详尽的上下文信息，包括当前模块的功能说明、相关的数据结构接口、以及待实现的具体需求。上下文越清晰，AI 输出的代码相关性和正确性越高。
* **明确分解任务**：将复杂功能拆解为小的子任务，多轮次逐步让 AI 生成代码。每次提示聚焦于一个具体功能点或文件，避免一次要求过多导致输出混乱。对于每个子任务，阐明"做什么"和**期望的实现方式**，例如指定使用何种框架 API 或遵循何种设计模式，以减少沟通成本。
* **引用已有代码/接口**：充分利用 Cursor 等AI开发工具的文件引用功能。在提示中直接引用相关的接口定义或示例代码片段，避免模糊描述。例如："请在 `dataBridge.ts` 中实现 `login(user, pass)` 方法，调用后端 `/api/login` 接口验证用户，并将结果保存到全局状态 (参见上文接口定义)"。通过 `@references` 或工具提供的方式指向具体文件或函数，可使请求更精确，从而提高代码生成质量。
* **审核与测试**：虽然Vibe Coding提倡"拥抱AI产出"，但开发者依然需要对生成的代码进行审查和本地运行测试。重点检查代码的正确性、效率和安全性。对于关键逻辑，必要时添加单元测试用例让 AI 协助生成。遇到明显问题时，可通过反馈提示让 AI 修正或重构有缺陷的部分，而不是手动大段修改，这符合 AI 对话编程的交互机制。

**（注）**: Vibe Coding 强调让 AI 承担编码细节，实现快速原型开发。开发者应保持**高层次思考**，关注架构设计和用户体验，把握整体方向，让 AI 辅助完成具体实现。通过良好提示词策略，AI 可以生成高质量代码，使我们摆脱繁琐的底层实现细节。

### 代码注释与风格

* **代码注释**：鼓励在关键逻辑处加入简明扼要的注释。特别是当代码由 AI 生成且逻辑复杂时，开发者应在阅读理解后添加注释解释意图，或要求 AI 在输出代码时包含必要的注释。模块接口、算法流程、特殊数值或判断等都应有注释辅助说明，方便日后维护和他人审阅。
* **编码风格**：统一采用 **TypeScript** 编写，遵循项目预设的 ESLint 规则和格式化规范（例如 Prettier）。命名采用驼峰式（CamelCase）或匈牙利标记法根据约定统一。组件和文件命名清晰语义化。尽量避免任何可能引起歧义的简写。坚持一个逻辑模块对应一个文件，文件内部逻辑适度分段并配以行内注释，提升代码可读性。
* **最佳实践**：遵循 React 和 TypeScript 的最佳实践。例如：尽可能使用函数式组件和 Hooks，实现**单一职责**原则；针对可能的空值或错误情况进行类型守卫和处理；避免任何会阻塞 UI 渲染的耗时操作（将其放入 WebWorker 或异步处理）。所有网络请求都通过统一的数据中间件封装，不在组件中直接调用 `fetch`，从源头上保证数据流动的可控性和一致性。

### 模块划分与文件组织

* **模块隔离**：严格按照功能将代码划分到各自模块文件夹中，禁止不同模块直接共享局部状态。模块之间通过明确的接口契约通信（例如调用 dataBridge 提供的方法，或使用全局状态管理的订阅/发布机制）。这种隔离确保一个模块的修改不会意外影响其他模块，提高代码健壮性和可维护性。
* **文件结构**：在每个模块目录下，根据需要进一步划分子组件或工具类文件。例如编辑器模块下，可按组件拆分为 `FileTree.tsx`（文件列表组件）、`TextEditor.tsx`（文本编辑子组件）、`Editor.tsx`（主编辑容器）等。每个文件内容应控制在合理大小，方便查阅和重构。当某文件逻辑超过单一职责范畴，应考虑拆解为更小组件或hooks。共享的类型定义放在 `src/types.ts` 或核心模块中集中维护，避免各处定义重复类型。
* **样式组织**：采用 TailwindCSS 工具类进行样式。尽量通过组合预设的 Tailwind 工具类实现设计稿要求，避免直接写冗长的CSS。如果某组件样式复杂，可使用 Tailwind 指定的 `@apply` 或定义少量自定义样式类。所有样式遵循统一设计规范（如色彩、间距、字体），在全局配置或约定的CSS文件集中管理。组件内部避免使用魔数（magic numbers）调整样式，需提炼为变量或Tailwind配置。

### Console 日志规范

* **调试日志**：在开发和测试阶段，可充分使用 `console.log` 等日志手段辅助调试。建议为关键的流程节点打印日志，例如：组件挂载/卸载、收到后台数据、发送请求、Yjs 文档同步事件、编译过程开始/结束等。这有助于在浏览器控制台快速追踪应用状态变化。日志内容应包含模块名称或功能标签，以便区分来源（例如 `"[Editor] Document loaded"`）。
* **日志管理**：为避免过多控制台输出干扰，可基于环境变量区分日志级别。开发环境开启详细日志，包括调试信息和警告；生产环境则只保留必要的错误日志。可以考虑封装一个简单的 `logger` 工具，根据 `NODE_ENV` 控制日志输出级别，代替直接使用 `console.log`。**注意**：切勿在日志中输出敏感信息（如用户密码、令牌等），以免安全隐患。
* **问题排查**：当出现难以诊断的行为时，通过二分法打印日志定位问题区域。例如在数据中间件的 state 更新前后打印状态、在协同编辑发生冲突时输出 Yjs 文档快照摘要等。利用日志及时发现并解决"脑裂"（数据源不一致）等问题。一旦问题解决，应适当移除冗余的日志，保持代码整洁。如果某些日志对理解系统流程很有帮助，可以保留但将其级别设为 debug，默认在生产中关闭。

## 统一数据结构接口 (TS Interface)

整个前端采用统一的数据结构定义，以确保各模块对数据的假设一致，减少接口集成过程中的对齐成本。下面列出主要的数据接口，在 TypeScript 中以 `interface` 定义：

```typescript
// 用户信息与会话
interface User {
  id: string;
  username: string;
  displayName?: string;
  email?: string;
  // ...其他可能的用户属性
}

// 项目及文件结构
interface Project {
  id: string;
  name: string;
  ownerId: string;                 // 拥有者用户ID
  files: FileEntry[];              // 项目包含的文件列表
  collaborators: ProjectMember[];  // 协作者列表及权限
  createdAt: string;
  updatedAt: string;
}

interface FileEntry {
  fileId: string;
  name: string;        // 文件名，如 "main.tex", "chap1.tex"
  path?: string;       // 文件路径（若支持目录，可包含目录路径，否则可省略）
  content?: string;    // 文件内容初始值（选填：打开项目时由后端提供初始内容）
  isMain?: boolean;    // 是否主文档（编译入口tex文件）
}

// 项目协作者及权限
type Role = 'owner' | 'editor' | 'viewer';
interface ProjectMember {
  userId: string;
  username: string;
  role: Role;
}

// 编译输出日志结构
interface CompileLogEntry {
  type: 'info' | 'warning' | 'error';
  message: string;
  file?: string;    // 所属文件（如果能确定）
  line?: number;    // 出现行号（如解析得到）
  timestamp?: number;
}
```

上述接口将应用于前后端数据交换和前端状态管理。例如，后端获取项目列表时返回的是 `Project` 数组，其中嵌套 `FileEntry` 简要信息（不一定含内容）；打开某项目时可通过API获取每个文件的初始文本内容用于加载编辑器。`Project.collaborators` 描述了项目共享情况，权限控制面板将根据此生成协作者列表 UI。编译日志 `CompileLogEntry` 用于统一前端编译输出的数据格式，`RunLogPanel` 通过读取该结构数组来渲染日志列表（不同类型日志可配不同样式）。

数据中间件模块 (`dataBridge.ts`) 会引用这些接口类型，以保证从后端获取的数据在存入前端全局状态前经过类型检查和转换。全体模块应以这些接口为合同进行数据交互，不应在各自内部私自定义不一致的数据格式。若需扩展数据结构，应在此集中修改定义并在 README 或文档中通知团队。

## 模块 TODO 列表

下面列出了按照模块划分的开发任务清单（ToDo List）。每个模块作为一个主要任务，包含若干子任务。开发过程中，团队可在完成子任务后勾选 `[x]` 标记，并在完成所有子任务后勾选模块任务，以跟踪进度。**每一轮迭代**聚焦若干模块的子任务，完毕后提交 Pull Request 并合并，再进行下一轮。任务清单如下：

* [ ] **前端数据中间件 (dataBridge)**

  * [ ] **API 调用封装**：实现与后端各接口的调用方法，例如：`login(username, password)`, `fetchProjects()`, `openProject(projectId)`，`saveFile(projectId, fileId, content)`，`addCollaborator(projectId, userId, role)` 等。使用 `fetch` 或 Axios 请求后端 REST API，并处理响应与错误。需设计统一的错误处理机制（如接口返回401未授权时触发全局登出）。
  * [ ] **全局状态管理**：选择 Zustand 或 Jotai 实现前端状态仓库。定义全局 state 包含：当前登录用户 `currentUser`、项目列表 `projects`、当前打开项目 `currentProject`（包含文件列表及可能的内容缓存）、当前项目的编译日志 `compileLogs`、协作会话状态等。提供更新函数 (actions) 供各模块触发。例如 `setCurrentProject(project)`, `updateFileContent(fileId, newContent)`，这些操作同时会保持 state 和 Yjs 文档的一致。
  * [ ] **数据同步逻辑**：在 dataBridge 内部，将后端获取的数据与本地 Yjs 协同内容桥接。当用户打开项目时，调用后端获取初始文件内容，然后初始化 Yjs 文档；在协同编辑过程中，定时或在用户保存时，通过后端API同步最新文档内容（或增量更新）。避免出现后端存储与前端状态不一致的问题。需要确保**单一数据源**：组件只从全局 state 读取数据，由 dataBridge 负责更新它，从而杜绝"多个来源各自维护数据"的反模式。

* [ ] **登录模块** (`Login`)

  * [ ] **UI 界面**：设计并实现登录页面，包括用户名、密码输入框和"登录"按钮。使用 TailwindCSS 美化表单，增加必要的前端校验（如必填提示、密码最小长度等）。
  * [ ] **登录流程**：在用户点击登录时，调用 `dataBridge.login(username, password)` 方法。后端返回成功则存储会话（如将 JWT 保存到 dataBridge 的 state 中并同步到 localStorage），然后路由跳转到项目列表页；如果登录失败（例如密码错误），UI 需提示错误消息。需处理登录过程中的加载状态（按钮禁用及 Loading 提示）。
  * [ ] **权限与注销**：登录模块还包括（可选）注册入口以及登录后注销的逻辑。实现一个简单的注销函数，如 `dataBridge.logout()`，清除本地状态并重定向回登录页。确保未登录用户无法访问受保护的路由（路由守卫），这一逻辑可以在路由配置或顶层组件中实现。

* [ ] **项目列表模块** (`ProjectList`)

  * [ ] **数据获取**：组件加载时，通过 `dataBridge.fetchProjects()` 拉取当前用户的项目列表数据。显示加载指示，等待数据返回后再渲染列表。若用户无任何项目，给予友好的空状态提示（如"暂无项目，请新建"）。
  * [ ] **列表渲染**：美观地展示项目列表，每个项目卡片显示名称、创建时间、拥有者等基本信息。可以使用列表或卡片布局。每个项目项允许点击打开（进入编辑器）、以及可能的管理操作（如重命名或删除按钮，可根据权限显示）。
  * [ ] **新建项目**：提供"新建项目"功能，点击后弹出对话框让用户输入项目名称等信息，然后调用 `dataBridge.createProject(name, ...)` 接口创建项目。成功后刷新项目列表并自动进入新项目的编辑页面。处理创建中的等待和错误（如重名冲突）提示。
  * [ ] **导航与路由**：配置从项目列表页面进入编辑器页面的路由流程。点击某项目后，保存所选项目ID到全局状态 `currentProject`，然后使用 React Router 导航到 `/editor/:projectId` 路由。确保编辑器模块能根据全局的 `currentProject` 正确加载内容。

* [ ] **编辑器模块** (`Editor`)

  * [ ] **初始化项目会话**：在进入编辑器页面时，通过项目ID调用 `dataBridge.openProject(projectId)`。该方法应获取项目详细信息和文件内容，并在前端初始化 Yjs 文档（一个 Y.Doc 对象）。将每个文件的文本内容载入 Yjs，例如为每个文件创建一个 `Y.Text` 类型并赋初始值，然后将这些文本类型存储在 Y.Doc 的 `Y.Map` 中（key 为文件ID或路径）。同时，连接 Yjs 提供器（websocket 或 webrtc）以加入协同会话，使后续编辑能够实时同步。
  * [ ] **文件列表/切换**：在编辑器界面左侧显示项目的文件树或文件列表（使用 `currentProject.files`）。支持点击选择不同文件，在右侧文本编辑区域显示相应文件内容。高亮当前编辑的文件。可能的话，实现简单的标签页(tab)界面，方便同时打开多个文件来回切换。
  * [ ] **文本编辑器集成**：在中心区域集成富文本编辑组件，建议使用 CodeMirror 6 或 Monaco Editor 等支持内容编辑的控件。将编辑器内容与 Yjs 文本绑定，使本地修改通过 CRDT 自动同步。【技术细节】若使用 CodeMirror，可利用其 Yjs binding 插件；否则需要手动侦听编辑器内容变化事件，将更新应用到对应的 `Y.Text`，并订阅 `Y.Text` 的更新事件以更新编辑器视图，从而实现多用户协同编辑效果。
  * [ ] **编译触发**：在编辑器界面提供"编译/运行"按钮。当用户点击编译时，调用 WASM LaTeX 编译器模块（例如 `compileProject(currentProject)`）。编译模块应当返回编译日志和 PDF 文件数据（可选）。调用过程需考虑异步和耗时操作：在编译进行时禁用编辑或按钮，并在界面上提供进度提示（如"正在编译..."）。编译完成后，如果成功生成 PDF，则触发预览更新；无论成功或失败，都将日志传递给运行日志面板显示。
  * [ ] **PDF预览**：在编辑器界面中预留区域（通常在右侧或下方）用于显示编译后的 PDF 文档预览。可采用 `<iframe>` 或 PDF.js 来渲染生成的 PDF（二进制数据转换为 blob URL）以供查看。实现预览区域的缩放、页面导航等基本交互功能。每次成功编译后，预览应自动更新；如果编译失败，则预览保持上次成功的版本并通过日志面板提示错误。
  * [ ] **协同光标和版本**（可选）：利用 Yjs 提供的额外特性，显示其他协作者的光标位置和名称标识（不同颜色指示）。在文档较长时，实现基本的**撤销/重做**功能（Yjs 自带版本快照机制），以便用户可以撤销误操作。此部分可视时间和需求酌情实现。
  * [ ] **错误处理**：在编辑器模块中，处理各种可能的错误情况。例如：打开项目时网络失败或无权限 -> 提示用户并返回项目列表；协同会话中途断开 -> 尝试自动重连并提示；编译过程中的异常（如编译器崩溃）-> 反馈给用户并在日志中记录详细信息。确保编辑器在各种异常情况下不会崩溃，至少给出友好提示并提供重试途径。

* [ ] **运行日志面板模块** (`RunLogPanel`)

  * [ ] **日志UI设计**：实现日志面板的用户界面，考虑放置在编辑器界面下方或右侧。采用可滚动的文本区域或列表显示日志，每条日志前附带类型标识（info/警告/错误不同颜色或图标）。错误和警告信息可使用醒目的样式，高亮关键字（如 "Error", "Warning", 以及 LaTeX 报错的行号等）。
  * [ ] **日志数据获取**：定义日志面板接受的数据接口，比如通过 `dataBridge` 提供 `compileLogs` 数组或回调 prop 将新日志传递进来。典型实现是在每次编译时清空旧日志，然后订阅编译过程的输出流，将每行日志通过 append 操作加入状态。对于 WASM 编译器，可以在其运行过程中提供一个日志回调，每产生一条日志就调用前端的处理函数。
  * [ ] **自动滚动与交互**：当日志输出很多时，实现日志容器自动滚动到底部，以便用户总是看到最新输出。提供一个开关按钮可以暂停自动滚动，以便用户拖动查看前面日志。对于包含文件名和行号的错误日志，考虑实现点击日志条目时，在编辑器中跳转到对应文件行（需要解析日志文本获取文件和行信息，并调用编辑器的定位方法）。
  * [ ] **日志持久化（可选）**：视需求决定是否将日志保存。可以在 dataBridge 中缓存最近一次编译日志，这样即使用户关闭日志面板或切换文件后再打开，还能看到之前的输出。后端若提供日志记录接口，也可在编译完成后将日志发送后端保存（供以后查看编译历史）。

* [ ] **权限控制面板模块** (`PermissionPanel`)

  * [ ] **成员列表显示**：实现权限面板 UI，列出当前项目的所有协作者。每行显示成员用户名、角色（拥有者/编辑者/阅读者等），以及相应的操作按钮（根据操作者权限决定可见性）。拥有者应能看到对其他成员的权限更改和移除按钮；编辑者可能只能邀请新成员，不可修改他人权限；阅读者通常无权管理成员。
  * [ ] **邀请新成员**：提供一个输入字段或对话框，让拥有者可以输入新成员的用户名或邮箱以发送邀请。调用后端邀请API (`dataBridge.inviteMember(projectId, userIdentifier, role)`)，成功后在列表中添加该成员（状态可能为"待接受"）。处理邀请中的错误情况（如用户不存在、权限不足等）并给予提示。
  * [ ] **权限变更**：在成员列表每项提供权限变更控件（如下拉选择角色）。当拥有者选择修改某成员的角色时，调用 `dataBridge.updateMemberRole(projectId, userId, newRole)` 接口发送请求，更新成功后反馈前端并刷新列表显示的新权限。只有拥有者或管理员可以执行此操作，UI 上应做相应权限判断隐藏不允许的控件。
  * [ ] **移除成员**：提供移除按钮（如一个"小叉"图标）以从项目中移除某协作者。点击后弹出确认框（防止误操作），确认后调用 `dataBridge.removeMember(projectId, userId)` 接口。后端返回成功则从当前列表中移除该用户行项，并在 UI 上提示"用户已移除"。如果尝试移除自己（拥有者无法移除自己或转让权限另算），需要给予错误提示并禁止此操作。
  * [ ] **界面交互细节**：在整个权限面板操作过程中，增加必要的交互细节，如操作成功或失败的 toast 通知反馈；修改权限或移除后列表的即时更新；邀请后表单清空等。确保并发情况下的数据一致性，例如两人同时邀请用户或修改权限时，通过后端最新结果刷新列表，避免冲突显示。

## 迭代协作流程

高效的协作开发流程对于多人参与和 AI 生成代码的项目尤为重要。我们采用 **迭代式开发** 加 **Pull Request 工作流** 的方式推进，每次迭代聚焦若干模块或功能，在分支中完成后通过 PR 合并主干。具体规范如下：

### Pull Request 规范

* **小步提交，聚焦单一模块/功能**：每个 Pull Request 应尽量短小且专注于一个议题。避免将不相关的功能混杂在同一个 PR 中。如果某次迭代涉及多个模块，应拆分为多个 PR 分开提交。这使代码审查更为容易，也降低合并冲突风险。原则上，"一个 PR 解决一件事情"。
* **分支命名与关联**：新功能或模块开发应从主干创建单独的分支进行，分支命名遵循约定，例如 `feat/editor-module`、`fix/login-error-msg` 等简明描述。提交 PR 时，在描述中关联对应的任务或Issue（如有），例如使用关键词 "Closes #ID" 或在PR描述中引用待办事项清单中的条目，以便自动关闭相关任务追踪。
* **PR 描述清晰**：Pull Request 描述需尽可能提供代码变更的上下文和原因。包括：本次完成的模块或功能概述，涉及的主要改动点列表，是否引入新依赖，特别需要关注的逻辑等。若是修复 bug，说明问题原因和解决思路；如是新增功能，简要说明使用方法或UI变化。
* **代码审核流程**：至少一名其他开发者（或代码所有者）需要审核 PR。对于 AI 生成的代码，更要仔细阅读其逻辑正确性和风格一致性。审查者可以直接在 GitHub PR 的文件变更处留下评论，提出修改建议或质疑。所有 review 意见需被处理（修改代码或解释原因）后方可合并。鼓励使用 GitHub 的 Review Approve 流程，审核通过后再由模块负责人或仓库管理员合并代码。
* **测试与CI**：在提交 PR 之前，开发者应在本地确保`npm run build`和`npm run lint`无错误，相关模块的功能经自测正常。CI/CD（如果配置了）会在 PR 打开时自动运行测试和构建，只有所有检查通过，PR 方可被合并。如果 CI 报错，开发者应及时修复并推送更新。通过这些措施，确保主干始终保持可运行状态。

### 提示词 (Prompt) 模板

在使用 AI 模型（如 Claude）进行代码生成时，编写高质量的提示词（Prompt）至关重要。为了在 Cursor 等对话式编程环境中取得最佳效果，我们提供一个通用的提示模板供参考：

```
[系统角色]:
你是一个经验丰富的前端工程师，熟悉 React、TypeScript、Yjs 协同编辑和 LaTeX 编译。

[用户提示]:
请根据项目的 README 文档和下面的任务列表，为 **[模块名称]** 编写代码实现。

模块简介: 
[在此简述模块作用，例如复制 README 中该模块描述的片段]

待完成任务:
1. [子任务1描述]
2. [子任务2描述]
...

开发要求:
- 使用 TypeScript 和 React 函数式组件，遵循项目编码规范和接口定义。
- 调用 dataBridge 提供的接口或全局状态完成数据交互。
- 确保代码可读、带有必要注释，并处理可能的错误情况。

请基于以上要求，给出 `[模块文件名].tsx` 的完整代码实现。
```

在实际使用时，可以按照以下步骤调整上述模板：

1. **提供模块上下文**：从 README 中拷贝该模块的简介要点，或在提示中引用相关章节。这让 AI 清楚模块的定位和已有信息。例如："模块简介"部分可直接引用 README 对应模块的描述。
2. **列出具体任务**：将尚未实现的功能点逐条罗列。尽量使用简洁描述，例如"实现表单验证逻辑""对接登录 API 并处理响应"等。保证这些表述与 ToDo 列表中的项一致，以便 AI 明确要完成哪些内容。
3. **明确技术要求**：提醒 AI 使用项目既定的技术栈和规范（React/TS、dataBridge接口等）。如果对性能或边缘情况有要求也一并指出，如"应防止重复提交""网络错误时需重试一次"等。
4. **输出格式**：通常让 AI 输出完整的代码文件内容。如果只是局部修改，也可要求其仅给出核心代码片段，但在 Cursor 环境下倾向于生成整个文件便于直接替换。

通过遵循以上模板，开发者能更有效地引导 AI 生成符合需求的代码。同时注意，每次生成后都要亲自阅读和测试，由于 AI 可能产生细微但关键的错误，人工审校仍是必要环节。

最后，团队应持续完善提示策略。例如，总结哪些表述有助于 AI 理解，哪些容易引起误解，从而在后续提示中加以改进。随着模块开发的推进，README 和任务列表也会更新，更要确保提示中使用的新信息与最新文档一致，以避免 AI 基于过期背景做出错误假设。

---

**附注**: 我们坚信，通过详细的规划和严格的规范，以及充分利用 AI 辅助编程的前沿方法，本项目的前端开发将高效而有条不紊地进行。每位团队成员应熟读本 README，确保对项目结构和流程有全面了解。在实践中如有更好的建议，也欢迎及时讨论并更新此文档。祝协作顺利，开发愉快！
